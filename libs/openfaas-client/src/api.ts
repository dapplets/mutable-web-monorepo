/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * OpenFaaS API Gateway
 * OpenFaaS API documentation
 *
 * OpenAPI spec version: 0.8.12
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url'
import * as isomorphicFetch from 'isomorphic-fetch'
import { Configuration } from './configuration'

const BASE_PATH = 'http://localhost:8080'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    } else {
      this.configuration = new Configuration()
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = 'RequiredError'
  constructor(
    public field: string,
    msg?: string
  ) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface DeleteFunctionRequest
 */
export interface DeleteFunctionRequest {
  /**
   * Name of deployed function
   * @type {string}
   * @memberof DeleteFunctionRequest
   */
  functionName: string
}
/**
 *
 * @export
 * @interface FunctionDeployment
 */
export interface FunctionDeployment {
  /**
   * Name of deployed function
   * @type {string}
   * @memberof FunctionDeployment
   */
  service: string
  /**
   * Docker image in accessible registry
   * @type {string}
   * @memberof FunctionDeployment
   */
  image: string
  /**
   * Namespace to deploy function to. When omitted, the default namespace is used, typically this is `openfaas-fn` but is configured by the provider.
   * @type {string}
   * @memberof FunctionDeployment
   */
  namespace?: string
  /**
   * Process for watchdog to fork, i.e. the command to start the function process.  This value configures the `fprocess` env variable.
   * @type {string}
   * @memberof FunctionDeployment
   */
  envProcess?: string
  /**
   *
   * @type {Array<string>}
   * @memberof FunctionDeployment
   */
  constraints?: Array<string>
  /**
   * Overrides to environmental variables
   * @type {{ [key: string]: string; }}
   * @memberof FunctionDeployment
   */
  envVars?: { [key: string]: string }
  /**
   *
   * @type {Array<string>}
   * @memberof FunctionDeployment
   */
  secrets?: Array<string>
  /**
   * A map of labels for making scheduling or routing decisions
   * @type {{ [key: string]: string; }}
   * @memberof FunctionDeployment
   */
  labels?: { [key: string]: string }
  /**
   * A map of annotations for management, orchestration, events and build tasks
   * @type {{ [key: string]: string; }}
   * @memberof FunctionDeployment
   */
  annotations?: { [key: string]: string }
  /**
   *
   * @type {FunctionResources}
   * @memberof FunctionDeployment
   */
  limits?: FunctionResources
  /**
   *
   * @type {FunctionResources}
   * @memberof FunctionDeployment
   */
  requests?: FunctionResources
  /**
   * Make the root filesystem of the function read-only
   * @type {boolean}
   * @memberof FunctionDeployment
   */
  readOnlyRootFilesystem?: boolean
  /**
   * Deprecated: Private registry base64-encoded basic auth (as present in ~/.docker/config.json)  Use a Kubernetes Secret with registry-auth secret type to provide this value instead.  This value is completely ignored.
   * @type {string}
   * @memberof FunctionDeployment
   */
  registryAuth?: string
  /**
   * Deprecated: Network, usually func_functions for Swarm.  This value is completely ignored.
   * @type {string}
   * @memberof FunctionDeployment
   */
  network?: string
}
/**
 *
 * @export
 * @interface FunctionResources
 */
export interface FunctionResources {
  /**
   * The amount of memory that is allocated for the function
   * @type {string}
   * @memberof FunctionResources
   */
  memory?: string
  /**
   * The amount of cpu that is allocated for the function
   * @type {string}
   * @memberof FunctionResources
   */
  cpu?: string
}
/**
 *
 * @export
 * @interface FunctionStatus
 */
export interface FunctionStatus {
  /**
   * The name of the function
   * @type {string}
   * @memberof FunctionStatus
   */
  name: string
  /**
   * The fully qualified docker image name of the function
   * @type {string}
   * @memberof FunctionStatus
   */
  image: string
  /**
   * The namespace of the function
   * @type {string}
   * @memberof FunctionStatus
   */
  namespace?: string
  /**
   * Process for watchdog to fork
   * @type {string}
   * @memberof FunctionStatus
   */
  envProcess?: string
  /**
   * environment variables for the function runtime
   * @type {{ [key: string]: string; }}
   * @memberof FunctionStatus
   */
  envVars?: { [key: string]: string }
  /**
   *
   * @type {Array<string>}
   * @memberof FunctionStatus
   */
  constraints?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof FunctionStatus
   */
  secrets?: Array<string>
  /**
   * A map of labels for making scheduling or routing decisions
   * @type {{ [key: string]: string; }}
   * @memberof FunctionStatus
   */
  labels?: { [key: string]: string }
  /**
   * A map of annotations for management, orchestration, events and build tasks
   * @type {{ [key: string]: string; }}
   * @memberof FunctionStatus
   */
  annotations?: { [key: string]: string }
  /**
   *
   * @type {FunctionResources}
   * @memberof FunctionStatus
   */
  limits?: FunctionResources
  /**
   *
   * @type {FunctionResources}
   * @memberof FunctionStatus
   */
  requests?: FunctionResources
  /**
   * removes write-access from the root filesystem mount-point.
   * @type {boolean}
   * @memberof FunctionStatus
   */
  readOnlyRootFilesystem?: boolean
  /**
   * The amount of invocations for the specified function
   * @type {number}
   * @memberof FunctionStatus
   */
  invocationCount?: number
  /**
   * Desired amount of replicas
   * @type {number}
   * @memberof FunctionStatus
   */
  replicas?: number
  /**
   * The current available amount of replicas
   * @type {number}
   * @memberof FunctionStatus
   */
  availableReplicas?: number
  /**
   * is the time read back from the faas backend's data store for when the function or its container was created.
   * @type {Date}
   * @memberof FunctionStatus
   */
  createdAt?: Date
  /**
   *
   * @type {FunctionUsage}
   * @memberof FunctionStatus
   */
  usage?: FunctionUsage
}
/**
 *
 * @export
 * @interface FunctionUsage
 */
export interface FunctionUsage {
  /**
   * is the increase in CPU usage since the last measurement equivalent to Kubernetes' concept of millicores.
   * @type {number}
   * @memberof FunctionUsage
   */
  cpu?: number
  /**
   * is the total memory usage in bytes.
   * @type {number}
   * @memberof FunctionUsage
   */
  totalMemoryBytes?: number
}
/**
 *
 * @export
 * @interface GatewayInfo
 */
export interface GatewayInfo {
  /**
   *
   * @type {ProviderInfo}
   * @memberof GatewayInfo
   */
  provider: ProviderInfo
  /**
   * version of the gateway
   * @type {VersionInfo}
   * @memberof GatewayInfo
   */
  version: VersionInfo
  /**
   * Platform architecture
   * @type {string}
   * @memberof GatewayInfo
   */
  arch: string
}
/**
 *
 * @export
 */
export type ListNamespaceResponse = Array<string>
/**
 *
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
  /**
   * the function name
   * @type {string}
   * @memberof LogEntry
   */
  name: string
  /**
   * the namespace of the function
   * @type {string}
   * @memberof LogEntry
   */
  namespace: string
  /**
   * the name/id of the specific function instance
   * @type {string}
   * @memberof LogEntry
   */
  instance: string
  /**
   * the timestamp of when the log message was recorded
   * @type {Date}
   * @memberof LogEntry
   */
  timestamp: Date
  /**
   * raw log message content
   * @type {string}
   * @memberof LogEntry
   */
  text: string
}
/**
 * Prometheus alert produced by AlertManager. This is only a subset of the full alert payload.
 * @export
 * @interface PrometheusAlert
 */
export interface PrometheusAlert {
  /**
   * The status of the alert
   * @type {string}
   * @memberof PrometheusAlert
   */
  status: string
  /**
   * The name of the receiver
   * @type {string}
   * @memberof PrometheusAlert
   */
  receiver: string
  /**
   * The list of alerts
   * @type {Array<PrometheusInnerAlert>}
   * @memberof PrometheusAlert
   */
  alerts: Array<PrometheusInnerAlert>
}
/**
 * A single alert produced by Prometheus
 * @export
 * @interface PrometheusInnerAlert
 */
export interface PrometheusInnerAlert {
  /**
   * The status of the alert
   * @type {string}
   * @memberof PrometheusInnerAlert
   */
  status: string
  /**
   *
   * @type {PrometheusInnerAlertLabel}
   * @memberof PrometheusInnerAlert
   */
  labels: PrometheusInnerAlertLabel
}
/**
 * A single label of a Prometheus alert
 * @export
 * @interface PrometheusInnerAlertLabel
 */
export interface PrometheusInnerAlertLabel {
  /**
   * The name of the alert
   * @type {string}
   * @memberof PrometheusInnerAlertLabel
   */
  alertname: string
  /**
   * The name of the function
   * @type {string}
   * @memberof PrometheusInnerAlertLabel
   */
  functionName: string
}
/**
 *
 * @export
 * @interface ProviderInfo
 */
export interface ProviderInfo {
  /**
   * The orchestration provider / implementation
   * @type {string}
   * @memberof ProviderInfo
   */
  provider: string
  /**
   *
   * @type {string}
   * @memberof ProviderInfo
   */
  orchestration: string
  /**
   * The version of the provider
   * @type {VersionInfo}
   * @memberof ProviderInfo
   */
  version: VersionInfo
}
/**
 *
 * @export
 * @interface ScaleServiceRequest
 */
export interface ScaleServiceRequest {
  /**
   * Name of deployed function
   * @type {string}
   * @memberof ScaleServiceRequest
   */
  serviceName: string
  /**
   * Namespace the function is deployed to.
   * @type {string}
   * @memberof ScaleServiceRequest
   */
  namespace: string
  /**
   * Number of replicas to scale to
   * @type {number}
   * @memberof ScaleServiceRequest
   */
  replicas: number
}
/**
 *
 * @export
 * @interface Secret
 */
export interface Secret extends SecretDescription {
  /**
   * Value of secret in plain-text
   * @type {string}
   * @memberof Secret
   */
  value?: string
  /**
   * Value of secret in base64.  This can be used to provide raw binary data when the `value` field is omitted.
   * @type {string}
   * @memberof Secret
   */
  rawValue?: string
}
/**
 *
 * @export
 * @interface SecretDescription
 */
export interface SecretDescription {
  /**
   * Name of secret
   * @type {string}
   * @memberof SecretDescription
   */
  name: string
  /**
   * Namespace of secret
   * @type {string}
   * @memberof SecretDescription
   */
  namespace?: string
}
/**
 *
 * @export
 * @interface SecretValues
 */
export interface SecretValues {
  /**
   * Value of secret in plain-text
   * @type {string}
   * @memberof SecretValues
   */
  value?: string
  /**
   * Value of secret in base64.  This can be used to provide raw binary data when the `value` field is omitted.
   * @type {string}
   * @memberof SecretValues
   */
  rawValue?: string
}
/**
 *
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
  /**
   *
   * @type {string}
   * @memberof VersionInfo
   */
  commitMessage?: string
  /**
   *
   * @type {string}
   * @memberof VersionInfo
   */
  sha: string
  /**
   *
   * @type {string}
   * @memberof VersionInfo
   */
  release: string
}
/**
 * FunctionApi - fetch parameter creator
 * @export
 */
export const FunctionApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Invoke a function asynchronously
     * @summary Invoke a function asynchronously in the default OpenFaaS namespace  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
     * @param {string} functionName Function name
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeAsync(functionName: string, body?: Object, options: any = {}): FetchArgs {
      // verify required parameter 'functionName' is not null or undefined
      if (functionName === null || functionName === undefined) {
        throw new RequiredError(
          'functionName',
          'Required parameter functionName was null or undefined when calling invokeAsync.'
        )
      }
      const localVarPath = `/async-function/{functionName}`.replace(
        `{${'functionName'}}`,
        encodeURIComponent(String(functionName))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Invoke a function asynchronously in an OpenFaaS namespace.
     * @summary Invoke a function asynchronously in an OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
     * @param {string} functionName Function name
     * @param {string} namespace Namespace of the function
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeAsyncNamespaced(
      functionName: string,
      namespace: string,
      body?: Object,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'functionName' is not null or undefined
      if (functionName === null || functionName === undefined) {
        throw new RequiredError(
          'functionName',
          'Required parameter functionName was null or undefined when calling invokeAsyncNamespaced.'
        )
      }
      // verify required parameter 'namespace' is not null or undefined
      if (namespace === null || namespace === undefined) {
        throw new RequiredError(
          'namespace',
          'Required parameter namespace was null or undefined when calling invokeAsyncNamespaced.'
        )
      }
      const localVarPath = `/async-function/{functionName}.{namespace}`
        .replace(`{${'functionName'}}`, encodeURIComponent(String(functionName)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Invoke a function in the default OpenFaaS namespace.
     * @summary Synchronously invoke a function defined in te default OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.
     * @param {string} functionName Function name
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeFunction(functionName: string, body?: Object, options: any = {}): FetchArgs {
      // verify required parameter 'functionName' is not null or undefined
      if (functionName === null || functionName === undefined) {
        throw new RequiredError(
          'functionName',
          'Required parameter functionName was null or undefined when calling invokeFunction.'
        )
      }
      const localVarPath = `/function/{functionName}`.replace(
        `{${'functionName'}}`,
        encodeURIComponent(String(functionName))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Invoke a function in an OpenFaaS namespace.
     * @summary Synchronously invoke a function defined in the specified namespace.  Any additional path segments and query parameters will be passed to the function as is.
     * @param {string} functionName Function name
     * @param {string} namespace Namespace of the function
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeFunctionNamespaced(
      functionName: string,
      namespace: string,
      body?: Object,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'functionName' is not null or undefined
      if (functionName === null || functionName === undefined) {
        throw new RequiredError(
          'functionName',
          'Required parameter functionName was null or undefined when calling invokeFunctionNamespaced.'
        )
      }
      // verify required parameter 'namespace' is not null or undefined
      if (namespace === null || namespace === undefined) {
        throw new RequiredError(
          'namespace',
          'Required parameter namespace was null or undefined when calling invokeFunctionNamespaced.'
        )
      }
      const localVarPath = `/function/{functionName}.{namespace}`
        .replace(`{${'functionName'}}`, encodeURIComponent(String(functionName)))
        .replace(`{${'namespace'}}`, encodeURIComponent(String(namespace)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = '*/*'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Object' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FunctionApi - functional programming interface
 * @export
 */
export const FunctionApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Invoke a function asynchronously
     * @summary Invoke a function asynchronously in the default OpenFaaS namespace  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
     * @param {string} functionName Function name
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeAsync(
      functionName: string,
      body?: Object,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FunctionApiFetchParamCreator(configuration).invokeAsync(
        functionName,
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Invoke a function asynchronously in an OpenFaaS namespace.
     * @summary Invoke a function asynchronously in an OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
     * @param {string} functionName Function name
     * @param {string} namespace Namespace of the function
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeAsyncNamespaced(
      functionName: string,
      namespace: string,
      body?: Object,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FunctionApiFetchParamCreator(configuration).invokeAsyncNamespaced(
        functionName,
        namespace,
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Invoke a function in the default OpenFaaS namespace.
     * @summary Synchronously invoke a function defined in te default OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.
     * @param {string} functionName Function name
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeFunction(
      functionName: string,
      body?: Object,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FunctionApiFetchParamCreator(configuration).invokeFunction(
        functionName,
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Invoke a function in an OpenFaaS namespace.
     * @summary Synchronously invoke a function defined in the specified namespace.  Any additional path segments and query parameters will be passed to the function as is.
     * @param {string} functionName Function name
     * @param {string} namespace Namespace of the function
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeFunctionNamespaced(
      functionName: string,
      namespace: string,
      body?: Object,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FunctionApiFetchParamCreator(
        configuration
      ).invokeFunctionNamespaced(functionName, namespace, body, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * FunctionApi - factory interface
 * @export
 */
export const FunctionApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Invoke a function asynchronously
     * @summary Invoke a function asynchronously in the default OpenFaaS namespace  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
     * @param {string} functionName Function name
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeAsync(functionName: string, body?: Object, options?: any) {
      return FunctionApiFp(configuration).invokeAsync(functionName, body, options)(fetch, basePath)
    },
    /**
     * Invoke a function asynchronously in an OpenFaaS namespace.
     * @summary Invoke a function asynchronously in an OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
     * @param {string} functionName Function name
     * @param {string} namespace Namespace of the function
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeAsyncNamespaced(functionName: string, namespace: string, body?: Object, options?: any) {
      return FunctionApiFp(configuration).invokeAsyncNamespaced(
        functionName,
        namespace,
        body,
        options
      )(fetch, basePath)
    },
    /**
     * Invoke a function in the default OpenFaaS namespace.
     * @summary Synchronously invoke a function defined in te default OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.
     * @param {string} functionName Function name
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeFunction(functionName: string, body?: Object, options?: any) {
      return FunctionApiFp(configuration).invokeFunction(
        functionName,
        body,
        options
      )(fetch, basePath)
    },
    /**
     * Invoke a function in an OpenFaaS namespace.
     * @summary Synchronously invoke a function defined in the specified namespace.  Any additional path segments and query parameters will be passed to the function as is.
     * @param {string} functionName Function name
     * @param {string} namespace Namespace of the function
     * @param {Object} [body] (Optional) data to pass to function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invokeFunctionNamespaced(
      functionName: string,
      namespace: string,
      body?: Object,
      options?: any
    ) {
      return FunctionApiFp(configuration).invokeFunctionNamespaced(
        functionName,
        namespace,
        body,
        options
      )(fetch, basePath)
    },
  }
}

/**
 * FunctionApi - object-oriented interface
 * @export
 * @class FunctionApi
 * @extends {BaseAPI}
 */
export class FunctionApi extends BaseAPI {
  /**
   * Invoke a function asynchronously
   * @summary Invoke a function asynchronously in the default OpenFaaS namespace  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
   * @param {string} functionName Function name
   * @param {Object} [body] (Optional) data to pass to function
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public invokeAsync(functionName: string, body?: Object, options?: any) {
    return FunctionApiFp(this.configuration).invokeAsync(
      functionName,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Invoke a function asynchronously in an OpenFaaS namespace.
   * @summary Invoke a function asynchronously in an OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.  See https://docs.openfaas.com/reference/async/.
   * @param {string} functionName Function name
   * @param {string} namespace Namespace of the function
   * @param {Object} [body] (Optional) data to pass to function
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public invokeAsyncNamespaced(
    functionName: string,
    namespace: string,
    body?: Object,
    options?: any
  ) {
    return FunctionApiFp(this.configuration).invokeAsyncNamespaced(
      functionName,
      namespace,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Invoke a function in the default OpenFaaS namespace.
   * @summary Synchronously invoke a function defined in te default OpenFaaS namespace.  Any additional path segments and query parameters will be passed to the function as is.
   * @param {string} functionName Function name
   * @param {Object} [body] (Optional) data to pass to function
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public invokeFunction(functionName: string, body?: Object, options?: any) {
    return FunctionApiFp(this.configuration).invokeFunction(
      functionName,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Invoke a function in an OpenFaaS namespace.
   * @summary Synchronously invoke a function defined in the specified namespace.  Any additional path segments and query parameters will be passed to the function as is.
   * @param {string} functionName Function name
   * @param {string} namespace Namespace of the function
   * @param {Object} [body] (Optional) data to pass to function
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public invokeFunctionNamespaced(
    functionName: string,
    namespace: string,
    body?: Object,
    options?: any
  ) {
    return FunctionApiFp(this.configuration).invokeFunctionNamespaced(
      functionName,
      namespace,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * InternalApi - fetch parameter creator
 * @export
 */
export const InternalApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Healthcheck for the gateway, indicates if the gateway is running and available
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthcheck(options: any = {}): FetchArgs {
      const localVarPath = `/healthz`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Prometheus metrics for the gateway
     * @summary Prometheus metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metrics(options: any = {}): FetchArgs {
      const localVarPath = `/metrics`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Scale a function based on an alert
     * @summary Event-sink for AlertManager, for auto-scaling  Internal use for AlertManager, requires valid AlertManager alert JSON
     * @param {PrometheusAlert} [body] Incoming alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scaleAlert(body?: PrometheusAlert, options: any = {}): FetchArgs {
      const localVarPath = `/system/alert`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'PrometheusAlert' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Healthcheck for the gateway, indicates if the gateway is running and available
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthcheck(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InternalApiFetchParamCreator(configuration).healthcheck(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Prometheus metrics for the gateway
     * @summary Prometheus metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metrics(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InternalApiFetchParamCreator(configuration).metrics(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Scale a function based on an alert
     * @summary Event-sink for AlertManager, for auto-scaling  Internal use for AlertManager, requires valid AlertManager alert JSON
     * @param {PrometheusAlert} [body] Incoming alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scaleAlert(
      body?: PrometheusAlert,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InternalApiFetchParamCreator(configuration).scaleAlert(
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Healthcheck for the gateway, indicates if the gateway is running and available
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthcheck(options?: any) {
      return InternalApiFp(configuration).healthcheck(options)(fetch, basePath)
    },
    /**
     * Prometheus metrics for the gateway
     * @summary Prometheus metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metrics(options?: any) {
      return InternalApiFp(configuration).metrics(options)(fetch, basePath)
    },
    /**
     * Scale a function based on an alert
     * @summary Event-sink for AlertManager, for auto-scaling  Internal use for AlertManager, requires valid AlertManager alert JSON
     * @param {PrometheusAlert} [body] Incoming alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scaleAlert(body?: PrometheusAlert, options?: any) {
      return InternalApiFp(configuration).scaleAlert(body, options)(fetch, basePath)
    },
  }
}

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
  /**
   * Healthcheck for the gateway, indicates if the gateway is running and available
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public healthcheck(options?: any) {
    return InternalApiFp(this.configuration).healthcheck(options)(this.fetch, this.basePath)
  }

  /**
   * Prometheus metrics for the gateway
   * @summary Prometheus metrics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public metrics(options?: any) {
    return InternalApiFp(this.configuration).metrics(options)(this.fetch, this.basePath)
  }

  /**
   * Scale a function based on an alert
   * @summary Event-sink for AlertManager, for auto-scaling  Internal use for AlertManager, requires valid AlertManager alert JSON
   * @param {PrometheusAlert} [body] Incoming alert
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InternalApi
   */
  public scaleAlert(body?: PrometheusAlert, options?: any) {
    return InternalApiFp(this.configuration).scaleAlert(body, options)(this.fetch, this.basePath)
  }
}
/**
 * SystemApi - fetch parameter creator
 * @export
 */
export const SystemApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new secret.
     * @param {Secret} body A new secret to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSecret(body: Secret, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createSecret.'
        )
      }
      const localVarPath = `/system/secrets`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Secret' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove a deployed function.
     * @summary Remove a deployed function.
     * @param {DeleteFunctionRequest} body Function to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFunction(body: DeleteFunctionRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteFunction.'
        )
      }
      const localVarPath = `/system/functions`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'DeleteFunctionRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Remove a secret.
     * @param {SecretDescription} body Secret to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSecret(body: SecretDescription, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteSecret.'
        )
      }
      const localVarPath = `/system/secrets`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'SecretDescription' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deploy a new function.
     * @summary Deploy a new function.
     * @param {FunctionDeployment} body Function to deploy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployFunction(body: FunctionDeployment, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deployFunction.'
        )
      }
      const localVarPath = `/system/functions`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'FunctionDeployment' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a stream of the logs for a specific function
     * @param {string} name Function name
     * @param {string} [namespace] Namespace of the function
     * @param {string} [instance] Instance of the function
     * @param {number} [tail] Sets the maximum number of log messages to return, &lt;&#x3D;0 means unlimited
     * @param {boolean} [follow] When true, the request will stream logs until the request timeout
     * @param {Date} [since] Only return logs after a specific date (RFC3339)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionLogs(
      name: string,
      namespace?: string,
      instance?: string,
      tail?: number,
      follow?: boolean,
      since?: Date,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling getFunctionLogs.'
        )
      }
      const localVarPath = `/system/logs`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      if (instance !== undefined) {
        localVarQueryParameter['instance'] = instance
      }

      if (tail !== undefined) {
        localVarQueryParameter['tail'] = tail
      }

      if (follow !== undefined) {
        localVarQueryParameter['follow'] = follow
      }

      if (since !== undefined) {
        localVarQueryParameter['since'] = (since as any).toISOString()
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the status of a function by name
     * @param {string} functionName Function name
     * @param {string} [namespace] Namespace of the function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionStatus(functionName: string, namespace?: string, options: any = {}): FetchArgs {
      // verify required parameter 'functionName' is not null or undefined
      if (functionName === null || functionName === undefined) {
        throw new RequiredError(
          'functionName',
          'Required parameter functionName was null or undefined when calling getFunctionStatus.'
        )
      }
      const localVarPath = `/system/function/{functionName}`.replace(
        `{${'functionName'}}`,
        encodeURIComponent(String(functionName))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (namespace !== undefined) {
        localVarQueryParameter['namespace'] = namespace
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a list of deployed functions
     * @summary Get a list of deployed functions with: stats and image digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctions(options: any = {}): FetchArgs {
      const localVarPath = `/system/functions`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get system provider information
     * @summary Get info such as provider version number and provider orchestrator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo(options: any = {}): FetchArgs {
      const localVarPath = `/system/info`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a list of namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNamespaces(options: any = {}): FetchArgs {
      const localVarPath = `/system/namespaces`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a list of secret names and metadata from the provider
     * @summary Get a list of secret names and metadata from the provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSecrets(options: any = {}): FetchArgs {
      const localVarPath = `/system/secrets`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Scale a function
     * @summary Scale a function to a specific replica count
     * @param {string} functionName Function name
     * @param {ScaleServiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scaleFunction(functionName: string, body?: ScaleServiceRequest, options: any = {}): FetchArgs {
      // verify required parameter 'functionName' is not null or undefined
      if (functionName === null || functionName === undefined) {
        throw new RequiredError(
          'functionName',
          'Required parameter functionName was null or undefined when calling scaleFunction.'
        )
      }
      const localVarPath = `/system/scale-function/{functionName}`.replace(
        `{${'functionName'}}`,
        encodeURIComponent(String(functionName))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'ScaleServiceRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update a function spec
     * @summary Update a function.
     * @param {FunctionDeployment} body Function to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction(body: FunctionDeployment, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateFunction.'
        )
      }
      const localVarPath = `/system/functions`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'FunctionDeployment' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update a secret.
     * @summary Update a secret, the value is replaced.
     * @param {Secret} body Secret to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSecret(body: Secret, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateSecret.'
        )
      }
      const localVarPath = `/system/secrets`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'Secret' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a new secret.
     * @param {Secret} body A new secret to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSecret(
      body: Secret,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).createSecret(
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Remove a deployed function.
     * @summary Remove a deployed function.
     * @param {DeleteFunctionRequest} body Function to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFunction(
      body: DeleteFunctionRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).deleteFunction(
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Remove a secret.
     * @param {SecretDescription} body Secret to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSecret(
      body: SecretDescription,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).deleteSecret(
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Deploy a new function.
     * @summary Deploy a new function.
     * @param {FunctionDeployment} body Function to deploy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployFunction(
      body: FunctionDeployment,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).deployFunction(
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Get a stream of the logs for a specific function
     * @param {string} name Function name
     * @param {string} [namespace] Namespace of the function
     * @param {string} [instance] Instance of the function
     * @param {number} [tail] Sets the maximum number of log messages to return, &lt;&#x3D;0 means unlimited
     * @param {boolean} [follow] When true, the request will stream logs until the request timeout
     * @param {Date} [since] Only return logs after a specific date (RFC3339)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionLogs(
      name: string,
      namespace?: string,
      instance?: string,
      tail?: number,
      follow?: boolean,
      since?: Date,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LogEntry> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).getFunctionLogs(
        name,
        namespace,
        instance,
        tail,
        follow,
        since,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Get the status of a function by name
     * @param {string} functionName Function name
     * @param {string} [namespace] Namespace of the function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionStatus(
      functionName: string,
      namespace?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FunctionStatus> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).getFunctionStatus(
        functionName,
        namespace,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Get a list of deployed functions
     * @summary Get a list of deployed functions with: stats and image digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctions(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FunctionStatus>> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).getFunctions(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Get system provider information
     * @summary Get info such as provider version number and provider orchestrator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GatewayInfo> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).getSystemInfo(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Get a list of namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNamespaces(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ListNamespaceResponse> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).listNamespaces(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Get a list of secret names and metadata from the provider
     * @summary Get a list of secret names and metadata from the provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSecrets(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SecretDescription> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).listSecrets(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Scale a function
     * @summary Scale a function to a specific replica count
     * @param {string} functionName Function name
     * @param {ScaleServiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scaleFunction(
      functionName: string,
      body?: ScaleServiceRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).scaleFunction(
        functionName,
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * update a function spec
     * @summary Update a function.
     * @param {FunctionDeployment} body Function to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction(
      body: FunctionDeployment,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).updateFunction(
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     * Update a secret.
     * @summary Update a secret, the value is replaced.
     * @param {Secret} body Secret to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSecret(
      body: Secret,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SystemApiFetchParamCreator(configuration).updateSecret(
        body,
        options
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Create a new secret.
     * @param {Secret} body A new secret to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSecret(body: Secret, options?: any) {
      return SystemApiFp(configuration).createSecret(body, options)(fetch, basePath)
    },
    /**
     * Remove a deployed function.
     * @summary Remove a deployed function.
     * @param {DeleteFunctionRequest} body Function to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFunction(body: DeleteFunctionRequest, options?: any) {
      return SystemApiFp(configuration).deleteFunction(body, options)(fetch, basePath)
    },
    /**
     * Remove a secret.
     * @param {SecretDescription} body Secret to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSecret(body: SecretDescription, options?: any) {
      return SystemApiFp(configuration).deleteSecret(body, options)(fetch, basePath)
    },
    /**
     * Deploy a new function.
     * @summary Deploy a new function.
     * @param {FunctionDeployment} body Function to deploy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deployFunction(body: FunctionDeployment, options?: any) {
      return SystemApiFp(configuration).deployFunction(body, options)(fetch, basePath)
    },
    /**
     * Get a stream of the logs for a specific function
     * @param {string} name Function name
     * @param {string} [namespace] Namespace of the function
     * @param {string} [instance] Instance of the function
     * @param {number} [tail] Sets the maximum number of log messages to return, &lt;&#x3D;0 means unlimited
     * @param {boolean} [follow] When true, the request will stream logs until the request timeout
     * @param {Date} [since] Only return logs after a specific date (RFC3339)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionLogs(
      name: string,
      namespace?: string,
      instance?: string,
      tail?: number,
      follow?: boolean,
      since?: Date,
      options?: any
    ) {
      return SystemApiFp(configuration).getFunctionLogs(
        name,
        namespace,
        instance,
        tail,
        follow,
        since,
        options
      )(fetch, basePath)
    },
    /**
     * Get the status of a function by name
     * @param {string} functionName Function name
     * @param {string} [namespace] Namespace of the function
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctionStatus(functionName: string, namespace?: string, options?: any) {
      return SystemApiFp(configuration).getFunctionStatus(
        functionName,
        namespace,
        options
      )(fetch, basePath)
    },
    /**
     * Get a list of deployed functions
     * @summary Get a list of deployed functions with: stats and image digest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctions(options?: any) {
      return SystemApiFp(configuration).getFunctions(options)(fetch, basePath)
    },
    /**
     * Get system provider information
     * @summary Get info such as provider version number and provider orchestrator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemInfo(options?: any) {
      return SystemApiFp(configuration).getSystemInfo(options)(fetch, basePath)
    },
    /**
     * Get a list of namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNamespaces(options?: any) {
      return SystemApiFp(configuration).listNamespaces(options)(fetch, basePath)
    },
    /**
     * Get a list of secret names and metadata from the provider
     * @summary Get a list of secret names and metadata from the provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSecrets(options?: any) {
      return SystemApiFp(configuration).listSecrets(options)(fetch, basePath)
    },
    /**
     * Scale a function
     * @summary Scale a function to a specific replica count
     * @param {string} functionName Function name
     * @param {ScaleServiceRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scaleFunction(functionName: string, body?: ScaleServiceRequest, options?: any) {
      return SystemApiFp(configuration).scaleFunction(functionName, body, options)(fetch, basePath)
    },
    /**
     * update a function spec
     * @summary Update a function.
     * @param {FunctionDeployment} body Function to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction(body: FunctionDeployment, options?: any) {
      return SystemApiFp(configuration).updateFunction(body, options)(fetch, basePath)
    },
    /**
     * Update a secret.
     * @summary Update a secret, the value is replaced.
     * @param {Secret} body Secret to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSecret(body: Secret, options?: any) {
      return SystemApiFp(configuration).updateSecret(body, options)(fetch, basePath)
    },
  }
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   * Create a new secret.
   * @param {Secret} body A new secret to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public createSecret(body: Secret, options?: any) {
    return SystemApiFp(this.configuration).createSecret(body, options)(this.fetch, this.basePath)
  }

  /**
   * Remove a deployed function.
   * @summary Remove a deployed function.
   * @param {DeleteFunctionRequest} body Function to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public deleteFunction(body: DeleteFunctionRequest, options?: any) {
    return SystemApiFp(this.configuration).deleteFunction(body, options)(this.fetch, this.basePath)
  }

  /**
   * Remove a secret.
   * @param {SecretDescription} body Secret to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public deleteSecret(body: SecretDescription, options?: any) {
    return SystemApiFp(this.configuration).deleteSecret(body, options)(this.fetch, this.basePath)
  }

  /**
   * Deploy a new function.
   * @summary Deploy a new function.
   * @param {FunctionDeployment} body Function to deploy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public deployFunction(body: FunctionDeployment, options?: any) {
    return SystemApiFp(this.configuration).deployFunction(body, options)(this.fetch, this.basePath)
  }

  /**
   * Get a stream of the logs for a specific function
   * @param {string} name Function name
   * @param {string} [namespace] Namespace of the function
   * @param {string} [instance] Instance of the function
   * @param {number} [tail] Sets the maximum number of log messages to return, &lt;&#x3D;0 means unlimited
   * @param {boolean} [follow] When true, the request will stream logs until the request timeout
   * @param {Date} [since] Only return logs after a specific date (RFC3339)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public getFunctionLogs(
    name: string,
    namespace?: string,
    instance?: string,
    tail?: number,
    follow?: boolean,
    since?: Date,
    options?: any
  ) {
    return SystemApiFp(this.configuration).getFunctionLogs(
      name,
      namespace,
      instance,
      tail,
      follow,
      since,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Get the status of a function by name
   * @param {string} functionName Function name
   * @param {string} [namespace] Namespace of the function
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public getFunctionStatus(functionName: string, namespace?: string, options?: any) {
    return SystemApiFp(this.configuration).getFunctionStatus(
      functionName,
      namespace,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Get a list of deployed functions
   * @summary Get a list of deployed functions with: stats and image digest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public getFunctions(options?: any) {
    return SystemApiFp(this.configuration).getFunctions(options)(this.fetch, this.basePath)
  }

  /**
   * Get system provider information
   * @summary Get info such as provider version number and provider orchestrator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public getSystemInfo(options?: any) {
    return SystemApiFp(this.configuration).getSystemInfo(options)(this.fetch, this.basePath)
  }

  /**
   * Get a list of namespaces
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public listNamespaces(options?: any) {
    return SystemApiFp(this.configuration).listNamespaces(options)(this.fetch, this.basePath)
  }

  /**
   * Get a list of secret names and metadata from the provider
   * @summary Get a list of secret names and metadata from the provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public listSecrets(options?: any) {
    return SystemApiFp(this.configuration).listSecrets(options)(this.fetch, this.basePath)
  }

  /**
   * Scale a function
   * @summary Scale a function to a specific replica count
   * @param {string} functionName Function name
   * @param {ScaleServiceRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public scaleFunction(functionName: string, body?: ScaleServiceRequest, options?: any) {
    return SystemApiFp(this.configuration).scaleFunction(
      functionName,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * update a function spec
   * @summary Update a function.
   * @param {FunctionDeployment} body Function to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public updateFunction(body: FunctionDeployment, options?: any) {
    return SystemApiFp(this.configuration).updateFunction(body, options)(this.fetch, this.basePath)
  }

  /**
   * Update a secret.
   * @summary Update a secret, the value is replaced.
   * @param {Secret} body Secret to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public updateSecret(body: Secret, options?: any) {
    return SystemApiFp(this.configuration).updateSecret(body, options)(this.fetch, this.basePath)
  }
}
